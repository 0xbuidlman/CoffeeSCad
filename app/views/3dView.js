// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(function(require) {
    var ThreeDView, csg, lightgl, marionette, threedView_template;
    lightgl = require('lightgl');
    csg = require('csg');
    marionette = require('marionette');
    threedView_template = require("text!templates/3dview.tmpl");
    ThreeDView = (function(_super) {

      __extends(ThreeDView, _super);

      ThreeDView.prototype.template = threedView_template;

      function ThreeDView(containerelement, width, height, initialdepth) {
        var gl, msg,
          _this = this;
        this.containerelement = containerelement;
        this.onDraw = __bind(this.onDraw, this);

        this.clear = __bind(this.clear, this);

        this.setCsg = __bind(this.setCsg, this);

        ThreeDView.__super__.constructor.call(this, options);
        console.log("in viewer init: container element");
        console.log(this.containerelement);
        this.width = width != null ? width : 800;
        this.height = height != null ? height : 600;
        this.initialdepth = initialdepth != null ? initialdepth : 50;
        gl = GL.create();
        this.gl = gl;
        this.angleX = 0;
        this.angleY = 0;
        this.viewpointX = 0;
        this.viewpointY = 0;
        this.viewpointZ = this.initialdepth;
        this.drawLines = false;
        this.lineOverlay = false;
        if (!OpenCoffeeScad.isChrome()) {
          msg = "Please note: OpenJsCad currently only runs reliably on Google Chrome!";
        }
        gl.canvas.width = this.width;
        gl.canvas.height = this.height;
        gl.viewport(0, 0, this.width, this.height);
        gl.matrixMode(gl.PROJECTION);
        gl.loadIdentity();
        gl.perspective(45, this.width / this.height, 0.5, 1000);
        gl.matrixMode(gl.MODELVIEW);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.clearColor(1, 1, 1, 1);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        gl.polygonOffset(1, 1);
        this.blackShader = new GL.Shader("void main() {gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;}", "void main() {gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);}");
        this.lightingShader = new GL.Shader("        varying vec3 color;        varying vec3 normal;        varying vec3 light;        void main() {          const vec3 lightDir = vec3(1.0, 2.0, 3.0) / 3.741657386773941;          light = lightDir;          color = gl_Color.rgb;          normal = gl_NormalMatrix * gl_Normal;          gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;        }", "        varying vec3 color;        varying vec3 normal;        varying vec3 light;        void main() {          vec3 n = normalize(normal);          float diffuse = max(0.0, dot(light, n));          float specular = pow(max(0.0, -reflect(light, n).z), 10.0) * sqrt(diffuse);          gl_FragColor = vec4(mix(color * (0.3 + 0.7 * diffuse), vec3(1.0), specular), 1.0);        }      ");
        this.containerelement.appendChild(gl.canvas);
        gl.onmousemove = function(e) {
          return _this.onMouseMove(e);
        };
        gl.ondraw = function(e) {
          return _this.onDraw();
        };
        this.clear();
      }

      ThreeDView.prototype.setCsg = function(csg) {
        this.mesh = this.csgToMesh(csg);
        this.onDraw();
      };

      ThreeDView.prototype.clear = function() {
        this.mesh = new GL.Mesh();
        this.onDraw();
      };

      ThreeDView.prototype.supported = function() {
        return !!this.gl;
      };

      ThreeDView.prototype.onMouseMove = function(e) {
        var factor;
        if (e.dragging) {
          e.preventDefault();
          if (e.altKey) {
            factor = 1e-2;
            this.viewpointZ *= Math.pow(2, factor * e.deltaY);
          } else if (e.shiftKey) {
            factor = 5e-3;
            this.viewpointX += factor * e.deltaX * this.viewpointZ;
            this.viewpointY -= factor * e.deltaY * this.viewpointZ;
          } else {
            this.angleY += e.deltaX * 2;
            this.angleX += e.deltaY * 2;
            this.angleX = Math.max(-90, Math.min(90, this.angleX));
          }
          return this.onDraw();
        }
      };

      ThreeDView.prototype.onDraw = function(e) {
        var gl;
        gl = this.gl;
        gl.makeCurrent();
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.loadIdentity();
        gl.translate(this.viewpointX, this.viewpointY, -this.viewpointZ);
        gl.rotate(this.angleX, 1, 0, 0);
        gl.rotate(this.angleY, 0, 1, 0);
        if (!this.lineOverlay) {
          gl.enable(gl.POLYGON_OFFSET_FILL);
        }
        this.lightingShader.draw(this.mesh, gl.TRIANGLES);
        if (!this.lineOverlay) {
          gl.disable(gl.POLYGON_OFFSET_FILL);
        }
        if (this.drawLines) {
          if (this.lineOverlay) {
            gl.disable(gl.DEPTH_TEST);
          }
          gl.enable(gl.BLEND);
          this.blackShader.draw(this.mesh, gl.LINES);
          gl.disable(gl.BLEND);
          if (this.lineOverlay) {
            return gl.enable(gl.DEPTH_TEST);
          }
        }
      };

      ThreeDView.prototype.csgToMesh = function(csg) {
        var color, colors, i, indices, mesh, numpolygons, polygon, polygonindex, polygons, smoothlighting, triangles, vertexTag2Index, vertices, _i, _j, _ref;
        csg = csg.canonicalized();
        mesh = new GL.Mesh({
          normals: true,
          colors: true
        });
        vertexTag2Index = {};
        vertices = [];
        colors = [];
        triangles = [];
        smoothlighting = false;
        polygons = csg.toPolygons();
        numpolygons = polygons.length;
        try {
          for (polygonindex = _i = 0; 0 <= numpolygons ? _i < numpolygons : _i > numpolygons; polygonindex = 0 <= numpolygons ? ++_i : --_i) {
            polygon = polygons[polygonindex];
            color = [0, 0, 1];
            if (polygon.shared && polygon.shared.color) {
              color = polygon.shared.color;
            }
            indices = polygon.vertices.map(function(vertex) {
              var vertexindex, vertextag;
              vertextag = vertex.getTag();
              vertexindex;

              if (smoothlighting && (__indexOf.call(vertexTag2Index, vertextag) >= 0)) {
                vertexindex = vertexTag2Index[vertextag];
              } else {
                vertexindex = vertices.length;
                vertexTag2Index[vertextag] = vertexindex;
                vertices.push([vertex.pos.x, vertex.pos.y, vertex.pos.z]);
                colors.push(color);
              }
              return vertexindex;
            });
            for (i = _j = 2, _ref = indices.length; 2 <= _ref ? _j < _ref : _j > _ref; i = 2 <= _ref ? ++_j : --_j) {
              triangles.push([indices[0], indices[i - 1], indices[i]]);
            }
          }
        } catch (e) {
          console.log("Error " + e);
        }
        mesh.triangles = triangles;
        mesh.vertices = vertices;
        mesh.colors = colors;
        mesh.computeWireframe();
        mesh.computeNormals();
        return mesh;
      };

      return ThreeDView;

    })(marionette.ItemView);
    return Viewer;
  });

}).call(this);
