// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(function(require) {
    var $, GlThreeView, GlViewSettings, THREE, csg, marionette, requestAnimationFrame, threedView_template;
    $ = require('jquery');
    marionette = require('marionette');
    csg = require('csg');
    THREE = require('three');
    threedView_template = require("text!templates/3dview.tmpl");
    requestAnimationFrame = require('anim');
    GlViewSettings = (function(_super) {

      __extends(GlViewSettings, _super);

      function GlViewSettings() {
        return GlViewSettings.__super__.constructor.apply(this, arguments);
      }

      GlViewSettings.prototype.defaults = {
        antialiasing: true,
        showgrid: true
      };

      return GlViewSettings;

    })(Backbone.Model);
    GlThreeView = (function(_super) {

      __extends(GlThreeView, _super);

      GlThreeView.prototype.template = threedView_template;

      GlThreeView.prototype.ui = {
        renderBlock: "#glArea"
      };

      GlThreeView.prototype.events = {
        'mousewheel': 'mousewheel',
        'mousedown': 'mousedown'
      };

      GlThreeView.prototype.mousewheel = function(ev) {
        /*ev = window.event or ev; # old IE support  
        delta = Math.max(-1, Math.min(1, (ev.wheelDelta or -ev.detail)))
        delta*=75
        if delta - @camera.position.z <= 100
          @camera.position.z-=delta
        return false
        */
        return this.fromCsgTest(this.model);
      };

      GlThreeView.prototype.mousemove = function(ev) {
        var moveMinMax, x_move, y_move;
        if (this.dragStart != null) {
          moveMinMax = 10;
          this.dragAmount = [this.dragStart.x - ev.offsetX, this.dragStart.y - ev.offsetY];
          x_move = Math.max(-moveMinMax, Math.min(moveMinMax, this.dragAmount[0] / 10));
          y_move = Math.max(-moveMinMax, Math.min(moveMinMax, this.dragAmount[1] / 10));
          this.camera.position.x += x_move;
          this.camera.position.y -= y_move;
          return false;
        }
      };

      GlThreeView.prototype.dragstart = function(ev) {
        return this.dragStart = {
          'x': ev.offsetX,
          'y': ev.offsetY
        };
      };

      GlThreeView.prototype.mouseup = function(ev) {
        var v, x, y;
        if (this.dragStart != null) {
          this.dragAmount = [this.dragStart.x - ev.offsetX, this.dragStart.y - ev.offsetY];
          this.dragStart = null;
        }
        /*console.log ev
        console.log "clientX: #{ev.clientX} clientY: #{ev.clientY}"
        console.log "clientX: #{ev.offsetX} clientY: #{ev.offsetY}"
        */

        x = ev.offsetX;
        y = ev.offsetY;
        return v = new THREE.Vector3((x / this.width) * 2 - 1, -(y / this.height) * 2 + 1, 0.5);
      };

      GlThreeView.prototype.mousedown = function(ev) {
        var x, y;
        x = ev.offsetX;
        y = ev.offsetY;
        this.selectObj(x, y);
        if (this.current != null) {
          return this.toCsgTest(this.current);
        }
      };

      GlThreeView.prototype.selectObj = function(mouseX, mouseY) {
        var intersects, newMat, ray, reset_col, v,
          _this = this;
        v = new THREE.Vector3((mouseX / this.width) * 2 - 1, -(mouseY / this.height) * 2 + 1, 0.5);
        this.projector.unprojectVector(v, this.camera);
        ray = new THREE.Ray(this.camera.position, v.subSelf(this.camera.position).normalize());
        intersects = ray.intersectObjects(this.controller.objects);
        reset_col = function() {
          var newMat;
          if (_this.current != null) {
            newMat = new THREE.MeshLambertMaterial({
              color: 0xCC0000
            });
            _this.current.material = newMat;
            return _this.current = null;
          }
        };
        if (intersects != null) {
          if (intersects.length > 0) {
            if (intersects[0].object.name !== "workplane") {
              this.current = intersects[0].object;
              console.log(this.current.name);
              newMat = new THREE.MeshBasicMaterial({
                color: 0x0000FF
              });
              return this.current.material = newMat;
            } else {
              return reset_col();
            }
          } else {
            return reset_col();
          }
        } else {
          return reset_col();
        }
      };

      function GlThreeView(options, settings) {
        this.fromCsgTest = __bind(this.fromCsgTest, this);

        this.animate = __bind(this.animate, this);

        this.onRender = __bind(this.onRender, this);

        this.addCage = __bind(this.addCage, this);

        this.addPlane = __bind(this.addPlane, this);

        this.setupLights = __bind(this.setupLights, this);

        this.addObjs = __bind(this.addObjs, this);

        this.addObjs2 = __bind(this.addObjs2, this);

        this.selectObj = __bind(this.selectObj, this);

        this.mousedown = __bind(this.mousedown, this);

        this.mouseup = __bind(this.mouseup, this);

        this.dragstart = __bind(this.dragstart, this);

        this.mousewheel = __bind(this.mousewheel, this);

        var ASPECT, FAR, NEAR,
          _this = this;
        GlThreeView.__super__.constructor.call(this, options);
        this.dragging = false;
        this.width = 800;
        this.height = 600;
        this.viewAngle = 45;
        ASPECT = this.width / this.height;
        NEAR = 1;
        FAR = 10000;
        this.renderer = new THREE.WebGLRenderer({
          clearColor: 0xEEEEEE,
          clearAlpha: 1,
          antialias: true
        });
        this.renderer.clear();
        this.camera = new THREE.PerspectiveCamera(this.viewAngle, ASPECT, NEAR, FAR);
        this.camera.position.z = 300;
        this.camera.position.y = 150;
        this.camera.position.x = 150;
        this.scene = new THREE.Scene();
        this.scene.add(this.camera);
        this.addObjs();
        this.setupLights();
        this.addPlane();
        this.addCage();
        this.renderer.setSize(this.width, this.height);
        this.controller = new THREE.Object3D();
        this.controller.setCurrent = function(current) {
          return _this.current = current;
        };
        this.controller.objects = this.scene.__objects;
        this.projector = new THREE.Projector();
        this.controls = new THREE.OrbitControls(this.camera);
        this.controls.autoRotate = false;
      }

      GlThreeView.prototype.addObjs2 = function() {
        this.cube = new THREE.Mesh(new THREE.CubeGeometry(50, 50, 50), new THREE.MeshBasicMaterial({
          color: 0x000000
        }));
        return this.scene.add(this.cube);
      };

      GlThreeView.prototype.addObjs = function() {
        var radius, rings, segments, sphere, sphereMaterial;
        sphereMaterial = new THREE.MeshLambertMaterial({
          color: 0xCC0000
        });
        radius = 50;
        segments = 16;
        rings = 16;
        sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, segments, rings), sphereMaterial);
        sphere.name = "Shinyyy";
        return this.scene.add(sphere);
      };

      GlThreeView.prototype.setupLights = function() {
        var pointLight;
        pointLight = new THREE.PointLight(0xFFFFFF);
        pointLight.position.x = 10;
        pointLight.position.y = 50;
        pointLight.position.z = 130;
        return this.scene.add(pointLight);
      };

      GlThreeView.prototype.addPlane = function() {
        var plane, planeGeo, planeMat;
        planeGeo = new THREE.PlaneGeometry(500, 500, 5, 5);
        planeMat = new THREE.MeshBasicMaterial({
          color: 0x808080,
          wireframe: true,
          shading: THREE.FlatShading
        });
        plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -30;
        plane.name = "workplane";
        return this.scene.add(plane);
      };

      GlThreeView.prototype.addCage = function() {
        var line, lineGeo, lineMat, v;
        v = function(x, y, z) {
          return new THREE.Vector3(x, y, z);
        };
        lineGeo = new THREE.Geometry();
        lineGeo.vertices.push(v(-50, 0, 0), v(50, 0, 0), v(0, -50, 0), v(0, 50, 0), v(0, 0, -50), v(0, 0, 50), v(-50, 50, -50), v(50, 50, -50), v(-50, -50, -50), v(50, -50, -50), v(-50, 50, 50), v(50, 50, 50), v(-50, -50, 50), v(50, -50, 50), v(-50, 0, 50), v(50, 0, 50), v(-50, 0, -50), v(50, 0, -50), v(-50, 50, 0), v(50, 50, 0), v(-50, -50, 0), v(50, -50, 0), v(50, -50, -50), v(50, 50, -50), v(-50, -50, -50), v(-50, 50, -50), v(50, -50, 50), v(50, 50, 50), v(-50, -50, 50), v(-50, 50, 50), v(0, -50, 50), v(0, 50, 50), v(0, -50, -50), v(0, 50, -50), v(50, -50, 0), v(50, 50, 0), v(-50, -50, 0), v(-50, 50, 0), v(50, 50, -50), v(50, 50, 50), v(50, -50, -50), v(50, -50, 50), v(-50, 50, -50), v(-50, 50, 50), v(-50, -50, -50), v(-50, -50, 50), v(-50, 0, -50), v(-50, 0, 50), v(50, 0, -50), v(50, 0, 50), v(0, 50, -50), v(0, 50, 50), v(0, -50, -50), v(0, -50, 50));
        lineMat = new THREE.LineBasicMaterial({
          color: 0x808080,
          lineWidth: 1
        });
        line = new THREE.Line(lineGeo, lineMat);
        line.type = THREE.Lines;
        return this.scene.add(line);
      };

      GlThreeView.prototype.onRender = function() {
        var container;
        container = $(this.ui.renderBlock);
        container.append(this.renderer.domElement);
        return this.animate();
      };

      GlThreeView.prototype.animate = function() {
        var t;
        t = new Date().getTime();
        this.camera.lookAt(this.scene.position);
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
        return requestAnimationFrame(this.animate);
      };

      GlThreeView.prototype.toCsgTest = function(mesh) {};

      GlThreeView.prototype.fromCsgTest = function(csg) {
        /*app = require 'app'
        app.csgProcessor.setCoffeeSCad(@model.get("content"))
        resultCSG = app.csgProcessor.csg
        console.log "resultCSG:"
        console.log resultCSG
        
        mesh = THREE.CSG.fromCSG(resultCSG)
        @scene.add
        */

      };

      return GlThreeView;

    })(marionette.ItemView);
    return {
      GlThreeView: GlThreeView,
      GlViewSettings: GlViewSettings
    };
  });

}).call(this);
