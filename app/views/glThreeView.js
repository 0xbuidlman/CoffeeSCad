// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(function(require) {
    var $, GlThreeView, GlViewSettings, MyAxisHelper, THREE, csg, detector, marionette, requestAnimationFrame, threedView_template, utils;
    $ = require('jquery');
    marionette = require('marionette');
    csg = require('csg');
    THREE = require('three');
    THREE.CSG = require('three_csg');
    detector = require('detector');
    utils = require('utils');
    threedView_template = require("text!templates/glThree.tmpl");
    requestAnimationFrame = require('anim');
    GlViewSettings = (function(_super) {

      __extends(GlViewSettings, _super);

      function GlViewSettings() {
        return GlViewSettings.__super__.constructor.apply(this, arguments);
      }

      GlViewSettings.prototype.defaults = {
        renderer: 'webgl',
        antialiasing: true,
        showGrid: true,
        showAxes: true,
        shadows: true
      };

      return GlViewSettings;

    })(Backbone.Model);
    MyAxisHelper = (function() {

      function MyAxisHelper(size, xcolor, ycolor, zcolor) {
        var geometry, material;
        geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(-size || -1, 0, 0), new THREE.Vector3(size || 1, 0, 0), new THREE.Vector3(0, -size || -1, 0), new THREE.Vector3(0, size || 1, 0), new THREE.Vector3(0, 0, -size || -1), new THREE.Vector3(0, 0, size || 1));
        geometry.colors.push(new THREE.Color(xcolor || 0xffaa00), new THREE.Color(xcolor || 0xffaa00), new THREE.Color(ycolor || 0xaaff00), new THREE.Color(ycolor || 0xaaff00), new THREE.Color(zcolor || 0x00aaff), new THREE.Color(zcolor || 0x00aaff));
        material = new THREE.LineBasicMaterial({
          vertexColors: THREE.VertexColors,
          linewidth: 1
        });
        return new THREE.Line(geometry, material, THREE.LinePieces);
      }

      return MyAxisHelper;

    })();
    GlThreeView = (function(_super) {

      __extends(GlThreeView, _super);

      GlThreeView.prototype.template = threedView_template;

      GlThreeView.prototype.ui = {
        renderBlock: "#glArea",
        glOverlayBlock: "#glOverlay",
        overlayDiv: "#overlay"
      };

      GlThreeView.prototype.events = {
        'mousemove': 'mousemove',
        'mouseup': 'mouseup',
        'mousewheel': 'mousewheel',
        'mousedown': 'mousedown',
        'contextmenu': 'rightclick',
        'DOMMouseScroll': 'mousewheel',
        "mousedown .toggleGrid": "toggleGrid",
        "mousedown .toggleAxes": "toggleAxes",
        "mousedown .toggleShadows": "toggleShadows",
        "mousedown .toggleAA": "toggleAA"
      };

      /*
          triggers: 
            "mousedown .toggleGrid":    "toggleGrid:mousedown"
            "mousedown .toggleAxes":    "toggleAxes:mousedown"
            "mousedown .toggleShadows": "toggleShadows:mousedown"
            "mousedown .toggleAA":      "toggleAA:mousedown"
      */


      GlThreeView.prototype.toggleGrid = function(ev) {
        var toggled;
        toggled = this.settings.get("showGrid");
        if (toggled) {
          this.settings.set("showGrid", false);
          this.scene.remove(this.plane);
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("showGrid", true);
          this.addPlane();
          $(ev.target).removeClass("uicon-off");
        }
        return false;
      };

      GlThreeView.prototype.toggleAxes = function(ev) {
        var toggled;
        toggled = this.settings.get("showAxes");
        if (toggled) {
          this.settings.set("showAxes", false);
          this.removeAxes();
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("showAxes", true);
          this.addAxes();
          $(ev.target).removeClass("uicon-off");
        }
        return false;
      };

      GlThreeView.prototype.toggleShadows = function(ev) {
        var planeMat, toggled;
        toggled = this.settings.get("shadows");
        if (toggled) {
          this.settings.set("shadows", false);
          this.renderer.clearTarget(this.light.shadowMap);
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("shadows", true);
          $(ev.target).removeClass("uicon-off");
        }
        this.renderer.shadowMapEnabled = this.settings.get("shadows");
        this.renderer.shadowMapAutoUpdate = this.settings.get("shadows");
        planeMat = new THREE.MeshLambertMaterial({
          color: 0xFFFFFF
        });
        this.plane.material = planeMat;
        return false;
      };

      GlThreeView.prototype.toggleAA = function(ev) {
        var toggled;
        toggled = this.settings.get("antialiasing");
        if (toggled) {
          this.settings.set("antialiasing", false);
          this.renderer.antialias = false;
          $(ev.target).addClass("uicon-off");
        } else {
          this.settings.set("antialiasing", true);
          this.renderer.antialias = true;
          $(ev.target).removeClass("uicon-off");
        }
        return false;
      };

      GlThreeView.prototype.rightclick = function(ev) {
        var x, y;
        normalizeEvent(ev);
        x = ev.offsetX;
        y = ev.offsetY;
        this.selectObj(x, y);
        ev.preventDefault();
        return false;
      };

      GlThreeView.prototype.mousewheel = function(ev) {
        var wheelDelta;
        ev = window.event || ev;
        wheelDelta = null;
        if (ev.originalEvent != null) {
          wheelDelta = ev.originalEvent.detail != null ? ev.originalEvent.detail * (-120) : void 0;
        } else {
          wheelDelta = ev.wheelDelta;
        }
        if (wheelDelta > 0) {
          this.controls.zoomOut();
        } else {
          this.controls.zoomIn();
        }
        ev.preventDefault();
        ev.stopPropagation();
        return false;
        /*ev = window.event or ev; # old IE support  
        delta = Math.max(-1, Math.min(1, (ev.wheelDelta or -ev.detail)))
        delta*=75
        if delta - @camera.position.z <= 100
          @camera.position.z-=delta
        return false
        */

      };

      GlThreeView.prototype.mousemove = function(ev) {
        /*if @dragStart?
          moveMinMax = 10
          
          @dragAmount=[@dragStart.x-ev.offsetX, @dragStart.y-ev.offsetY]
          #@dragAmount[1]=@height-@dragAmount[1]
          #console.log "bleh #{@dragAmount[0]/500}"
          x_move = Math.max(-moveMinMax, Math.min(moveMinMax, @dragAmount[0]/10))
          y_move = Math.max(-moveMinMax, Math.min(moveMinMax, @dragAmount[1]/10))
          #x_move = (x_move/x_move+0.0001)*moveMinMax
          #y_move = (y_move/y_move+0.0001)*moveMinMax
          #console.log("moving by #{y_move}")
          @camera.position.x+=  x_move #@dragAmount.x/10000
          @camera.position.y-=  y_move#@dragAmount.y/100
          return false
        */

      };

      GlThreeView.prototype.dragstart = function(ev) {
        return this.dragStart = {
          'x': ev.offsetX,
          'y': ev.offsetY
        };
      };

      GlThreeView.prototype.mouseup = function(ev) {};

      GlThreeView.prototype.mousedown = function(ev) {};

      GlThreeView.prototype.selectObj = function(mouseX, mouseY) {
        var draw_impact, intersects, newMat, ray, reset_col, v,
          _this = this;
        v = new THREE.Vector3((mouseX / this.width) * 2 - 1, -(mouseY / this.height) * 2 + 1, 0.5);
        this.projector.unprojectVector(v, this.camera);
        ray = new THREE.Ray(this.camera.position, v.subSelf(this.camera.position).normalize());
        intersects = ray.intersectObjects(this.controller.objects);
        reset_col = function() {
          if (_this.current != null) {
            _this.current.material = _this.current.origMaterial;
            if (_this.current.cageView != null) {
              _this.scene.remove(_this.current.cageView);
            }
            return _this.current = null;
          }
        };
        draw_impact = function(position) {
          var sprite;
          sprite = new THREE.Sprite({
            map: _this.particleTexture,
            transparent: true,
            useScreenCoordinates: false,
            scaleByViewport: false
          });
          sprite.position = position;
          return _this.scene.add(sprite);
        };
        if (intersects != null) {
          if (intersects.length > 0) {
            if (intersects[0].object.name !== "workplane") {
              if (this.current !== intersects[0].object) {
                this.current = intersects[0].object;
                newMat = new THREE.MeshLambertMaterial({
                  color: 0xCC0000
                });
                this.current.origMaterial = this.current.material;
                this.current.material = newMat;
                this.addCage(this.current);
                if (this.current.cageView != null) {
                  return this.scene.add(this.current.cageView);
                }
              }
            } else {
              return reset_col();
            }
          } else {
            return reset_col();
          }
        } else {
          return reset_col();
        }
      };

      GlThreeView.prototype.switchModel = function(newModel) {
        this.scene.remove(this.mesh);
        this.controller.objects = [];
        this.model = newModel;
        return this.bindTo(this.model, "change", this.modelChanged);
      };

      GlThreeView.prototype.modelChanged = function(model, value) {
        return this.fromCsg(this.model);
      };

      function GlThreeView(options, settings) {
        this.addObjs = __bind(this.addObjs, this);

        this.fromCsg = __bind(this.fromCsg, this);

        this.animate = __bind(this.animate, this);

        this.onRender = __bind(this.onRender, this);

        this.drawText = __bind(this.drawText, this);

        this.addCage = __bind(this.addCage, this);

        this.addPlane = __bind(this.addPlane, this);

        this.setupLights = __bind(this.setupLights, this);

        this.configure = __bind(this.configure, this);

        this.modelChanged = __bind(this.modelChanged, this);

        this.selectObj = __bind(this.selectObj, this);

        this.mousedown = __bind(this.mousedown, this);

        this.mouseup = __bind(this.mouseup, this);

        this.dragstart = __bind(this.dragstart, this);

        this.mousewheel = __bind(this.mousewheel, this);

        this.rightclick = __bind(this.rightclick, this);

        this.toggleAA = __bind(this.toggleAA, this);

        this.toggleShadows = __bind(this.toggleShadows, this);

        this.toggleAxes = __bind(this.toggleAxes, this);

        this.toggleGrid = __bind(this.toggleGrid, this);
        GlThreeView.__super__.constructor.call(this, options);
        this.settings = options.settings || new GlViewSettings();
        this.bindTo(this.model, "change", this.modelChanged);
        this.dragging = false;
        this.width = 800;
        this.height = 600;
        this.renderer = null;
        this.setupScene();
        this.setupOverlayScene();
        this.configure(this.settings);
        if (this.settings) {
          if (this.settings.get("showGrid")) {
            this.addPlane();
          }
          if (this.settings.get("showAxes")) {
            this.addAxes();
          }
          if (this.settings.get("shadows")) {
            this.renderer.shadowMapEnabled = true;
          }
        }
        this.controller = new THREE.Object3D();
        this.controller.name = "picker";
        this.controller.objects = [];
        this.projector = new THREE.Projector();
      }

      GlThreeView.prototype.configure = function(settings) {
        var renderer;
        if (settings.get("renderer")) {
          renderer = settings.get("renderer");
          if (renderer === "webgl") {
            if (detector.webgl) {
              this.renderer = new THREE.WebGLRenderer({
                clearColor: 0x00000000,
                clearAlpha: 0,
                antialias: true
              });
              this.renderer.clear();
              this.renderer.setSize(this.width, this.height);
              this.overlayRenderer = new THREE.WebGLRenderer({
                clearColor: 0x000000,
                clearAlpha: 0,
                antialias: true
              });
              return this.overlayRenderer.setSize(350, 250);
            } else if (!detector.webgl && !detector.canvas) {
              return console.log("No Webgl and no canvas (fallback) support, cannot render");
            } else if (!detector.webgl && detector.canvas) {
              this.renderer = new THREE.CanvasRenderer({
                clearColor: 0x00000000,
                clearAlpha: 0,
                antialias: true
              });
              this.renderer.clear();
              this.overlayRenderer = new THREE.CanvasRenderer({
                clearColor: 0x000000,
                clearAlpha: 0,
                antialias: true
              });
              this.overlayRenderer.setSize(350, 250);
              return this.renderer.setSize(this.width, this.height);
            } else {
              return console.log("No Webgl and no canvas (fallback) support, cannot render");
            }
          } else if (renderer === "canvas") {
            if (detector.canvas) {
              this.renderer = new THREE.CanvasRenderer({
                clearColor: 0x00000000,
                clearAlpha: 0,
                antialias: true
              });
              this.renderer.clear();
              this.overlayRenderer = new THREE.CanvasRenderer({
                clearColor: 0x000000,
                clearAlpha: 0,
                antialias: true
              });
              this.overlayRenderer.setSize(350, 250);
              return this.renderer.setSize(this.width, this.height);
            } else if (!detector.canvas) {
              return console.log("No canvas support, cannot render");
            }
          }
        }
      };

      GlThreeView.prototype.setupScene = function() {
        var ASPECT, FAR, NEAR;
        this.viewAngle = 45;
        ASPECT = this.width / this.height;
        NEAR = 1;
        FAR = 10000;
        this.camera = new THREE.PerspectiveCamera(this.viewAngle, ASPECT, NEAR, FAR);
        this.camera.position.z = 500;
        this.camera.position.y = 250;
        this.camera.position.x = -250;
        this.scene = new THREE.Scene();
        this.scene.add(this.camera);
        return this.setupLights();
      };

      GlThreeView.prototype.setupOverlayScene = function() {
        var ASPECT, FAR, NEAR;
        ASPECT = (this.width / 2) / (this.height / 2);
        NEAR = 1;
        FAR = 10000;
        this.overlayCamera = new THREE.PerspectiveCamera(this.viewAngle, ASPECT, NEAR, FAR);
        this.overlayCamera.position.z = this.camera.position.z / 1.5;
        this.overlayCamera.position.y = this.camera.position.y / 1.5;
        this.overlayCamera.position.x = this.camera.position.x / 1.5;
        this.overlayscene = new THREE.Scene();
        return this.overlayscene.add(this.overlayCamera);
      };

      GlThreeView.prototype.setupLights = function() {
        var ambientLight, pointLight, spotLight;
        pointLight = new THREE.PointLight(0x333333, 5);
        pointLight.position.x = -2200;
        pointLight.position.y = -2200;
        pointLight.position.z = 3000;
        this.ambientColor = '0x253565';
        ambientLight = new THREE.AmbientLight(this.ambientColor);
        spotLight = new THREE.SpotLight(0xbbbbbb, 2);
        spotLight.position.x = 0;
        spotLight.position.y = 1000;
        spotLight.position.z = 0;
        spotLight.castShadow = this.settings.get("shadows");
        this.light = spotLight;
        this.scene.add(ambientLight);
        this.scene.add(pointLight);
        return this.scene.add(spotLight);
      };

      GlThreeView.prototype.addPlane = function() {
        var plane, planeGeo, planeMat;
        if (!this.plane) {
          planeGeo = new THREE.PlaneGeometry(500, 500, 5, 5);
          planeMat = new THREE.MeshBasicMaterial({
            color: 0x808080,
            wireframe: true,
            shading: THREE.FlatShading
          });
          planeMat = new THREE.MeshLambertMaterial({
            color: 0xFFFFFF
          });
          plane = new THREE.Mesh(planeGeo, planeMat);
          plane.rotation.x = -Math.PI / 2;
          plane.position.y = -30;
          plane.name = "workplane";
          plane.receiveShadow = this.settings.get("shadows");
          this.plane = plane;
        }
        return this.scene.add(this.plane);
      };

      GlThreeView.prototype.addAxes = function() {
        this.axes = new MyAxisHelper(200, 0x666666, 0x666666, 0x666666);
        this.scene.add(this.axes);
        this.xArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 50, 0xFF7700);
        this.yArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 50, 0x77FF00);
        this.zArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 50, 0x0077FF);
        this.overlayscene.add(this.xArrow);
        this.overlayscene.add(this.yArrow);
        this.overlayscene.add(this.zArrow);
        this.xLabel = this.drawText("X");
        this.xLabel.position.set(55, 0, 0);
        this.overlayscene.add(this.xLabel);
        this.yLabel = this.drawText("Y");
        this.yLabel.position.set(0, 0, 55);
        this.overlayscene.add(this.yLabel);
        this.zLabel = this.drawText("Z");
        this.zLabel.position.set(0, 55, 0);
        return this.overlayscene.add(this.zLabel);
      };

      GlThreeView.prototype.removeAxes = function() {
        this.scene.remove(this.axes);
        this.overlayscene.remove(this.xArrow);
        this.overlayscene.remove(this.yArrow);
        this.overlayscene.remove(this.zArrow);
        this.overlayscene.remove(this.xLabel);
        this.overlayscene.remove(this.yLabel);
        return this.overlayscene.remove(this.zLabel);
      };

      GlThreeView.prototype.addCage = function(mesh) {
        var bbox, cage, cageGeo, delta, height, length, lineMat, middlePoint, truc, v, width;
        bbox = mesh.geometry.boundingBox;
        length = bbox.max.x - bbox.min.x;
        width = bbox.max.y - bbox.min.y;
        height = bbox.max.z - bbox.min.z;
        cageGeo = new THREE.CubeGeometry(length, width, height);
        v = function(x, y, z) {
          return new THREE.Vector3(x, y, z);
        };
        lineMat = new THREE.LineBasicMaterial({
          color: 0x808080,
          lineWidth: 1,
          wireframe: true
        });
        lineMat = new THREE.MeshBasicMaterial({
          color: 0x808080,
          wireframe: true,
          shading: THREE.FlatShading
        });
        cage = new THREE.Mesh(cageGeo, lineMat);
        middlePoint = function(geometry) {
          var middle;
          middle = new THREE.Vector3();
          middle.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x) / 2;
          middle.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y) / 2;
          middle.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z) / 2;
          return middle;
        };
        delta = middlePoint(mesh.geometry);
        cage.position = delta;
        truc = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(-length / 2, -width / 2, height / 2), width - 15, 0xFF7700);
        cage.add(truc);
        return mesh.cageView = cage;
      };

      GlThreeView.prototype.drawText = function(text) {
        var canvas, context, sprite, texture;
        canvas = document.createElement('canvas');
        canvas.width = 640;
        canvas.height = 640;
        context = canvas.getContext('2d');
        context.font = "17px sans-serif";
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        sprite = new THREE.Sprite({
          map: texture,
          transparent: false,
          useScreenCoordinates: false,
          scaleByViewport: false
        });
        return sprite;
      };

      GlThreeView.prototype.setupPickerHelper = function() {
        var PI2, canvas, context, texture;
        canvas = document.createElement('canvas');
        canvas.width = 100;
        canvas.height = 100;
        context = canvas.getContext('2d');
        PI2 = Math.PI * 2;
        context.beginPath();
        context.arc(0, 0, 1, 0, PI2, true);
        context.closePath();
        context.fill();
        context.fillText("X", 40, 40);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        this.particleTexture = new THREE.Texture(canvas);
        this.particleTexture.needsUpdate = true;
        return this.particleMaterial = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          color: 0x000000
        });
      };

      GlThreeView.prototype.onRender = function() {
        var container, container2, selectors;
        selectors = this.ui.overlayDiv.children(" .uicons");
        selectors.tooltip();
        container = $(this.ui.renderBlock);
        container.append(this.renderer.domElement);
        this.controls = new THREE.OrbitControls(this.camera, this.el);
        this.controls.autoRotate = false;
        container2 = $(this.ui.glOverlayBlock);
        container2.append(this.overlayRenderer.domElement);
        this.overlayControls = new THREE.OrbitControls(this.overlayCamera, this.el);
        this.overlayControls.autoRotate = false;
        this.overlayControls.userZoomSpeed = 0;
        return this.animate();
      };

      GlThreeView.prototype.animate = function() {
        this.camera.lookAt(this.scene.position);
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
        this.overlayCamera.lookAt(this.overlayscene.position);
        this.overlayControls.update();
        this.overlayRenderer.render(this.overlayscene, this.overlayCamera);
        return requestAnimationFrame(this.animate);
      };

      GlThreeView.prototype.toCsgTest = function(mesh) {
        var csgResult;
        csgResult = THREE.CSG.toCSG(mesh);
        if (csgResult != null) {
          return console.log("CSG conversion result ok:");
        }
      };

      GlThreeView.prototype.fromCsg = function(csg) {
        var app, geom, mat, resultCSG, shine, spec;
        try {
          app = require('app');
          resultCSG = app.csgProcessor.processScript(this.model.get("content"));
          geom = THREE.CSG.fromCSG(resultCSG);
          mat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            shading: THREE.FlatShading,
            vertexColors: THREE.VertexColors
          });
          mat = new THREE.LineBasicMaterial({
            color: 0xFFFFFF,
            lineWidth: 1
          });
          mat = new THREE.MeshLambertMaterial({
            color: 0xFFFFFF,
            shading: THREE.FlatShading,
            vertexColors: THREE.VertexColors
          });
          shine = 1500;
          spec = 10000000000;
          mat = new THREE.MeshPhongMaterial({
            color: 0xFFFFFF,
            shading: THREE.SmoothShading,
            shininess: shine,
            specular: spec,
            metal: true,
            vertexColors: THREE.VertexColors
          });
          if (this.mesh != null) {
            this.scene.remove(this.mesh);
          }
          this.mesh = new THREE.Mesh(geom, mat);
          this.mesh.castShadow = this.settings.get("shadows");
          this.mesh.name = "CSG_OBJ";
          this.scene.add(this.mesh);
          return this.controller.objects = [this.mesh];
        } catch (error) {
          this.scene.remove(this.mesh);
          return console.log("Csg Generation error: " + error + " ");
        }
      };

      GlThreeView.prototype.addObjs = function() {
        var radius, rings, segments, sphere, sphereMaterial;
        this.cube = new THREE.Mesh(new THREE.CubeGeometry(50, 50, 50), new THREE.MeshBasicMaterial({
          color: 0x000000
        }));
        this.scene.add(this.cube);
        sphereMaterial = new THREE.MeshLambertMaterial({
          color: 0xCC0000
        });
        radius = 50;
        segments = 16;
        rings = 16;
        sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, segments, rings), sphereMaterial);
        sphere.name = "Shinyyy";
        return this.scene.add(sphere);
      };

      return GlThreeView;

    })(marionette.ItemView);
    return {
      GlThreeView: GlThreeView,
      GlViewSettings: GlViewSettings
    };
  });

}).call(this);
