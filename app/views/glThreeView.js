// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require) {
    var $, GlThreeView, THREE, marionette, requestAnimationFrame, threedView_template;
    $ = require('jquery');
    marionette = require('marionette');
    THREE = require('three');
    threedView_template = require("text!templates/3dview.tmpl");
    requestAnimationFrame = require('anim');
    GlThreeView = (function(_super) {

      __extends(GlThreeView, _super);

      GlThreeView.prototype.template = threedView_template;

      GlThreeView.prototype.ui = {
        renderBlock: "#glArea"
      };

      GlThreeView.prototype.triggers = {
        'mousedown': 'mdown'
      };

      GlThreeView.prototype.events = {
        'mousemove': 'mousemove',
        'mouseup': 'mouseup'
      };

      GlThreeView.prototype.mousemove = function(ev) {};

      GlThreeView.prototype.mouseup = function(ev) {
        /*console.log ev
        console.log "clientX: #{ev.clientX} clientY: #{ev.clientY}"
        console.log "clientX: #{ev.offsetX} clientY: #{ev.offsetY}"
        */

        var intersects, newMat, ray, v, x, y;
        x = ev.offsetX;
        y = ev.offsetY;
        v = new THREE.Vector3((x / this.width) * 2 - 1, -(y / this.height) * 2 + 1, 0.5);
        this.projector.unprojectVector(v, this.camera);
        ray = new THREE.Ray(this.camera.position, v.subSelf(this.camera.position).normalize());
        intersects = ray.intersectObjects(this.controller.objects);
        if (intersects != null) {
          if (intersects.length > 0) {
            this.controller.setCurrent(intersects[0].object);
            console.log(this.current.name);
            newMat = new THREE.MeshLambertMaterial({
              color: 0x0000FF
            });
            return this.current.material = newMat;
          } else {
            if (this.current != null) {
              newMat = new THREE.MeshLambertMaterial({
                color: 0xCC0000
              });
              this.current.material = newMat;
              return this.current = null;
            }
          }
        }
      };

      function GlThreeView(options) {
        this.animate = __bind(this.animate, this);

        this.onRender = __bind(this.onRender, this);

        this.addStuff = __bind(this.addStuff, this);

        this.addPlane = __bind(this.addPlane, this);

        this.setupLights = __bind(this.setupLights, this);

        this.addObjs = __bind(this.addObjs, this);

        this.addObjs2 = __bind(this.addObjs2, this);

        this.mouseup = __bind(this.mouseup, this);

        var ASPECT, FAR, NEAR,
          _this = this;
        GlThreeView.__super__.constructor.call(this, options);
        this.width = 800;
        this.height = 600;
        this.viewAngle = 45;
        ASPECT = this.width / this.height;
        NEAR = 1;
        FAR = 10000;
        this.renderer = new THREE.WebGLRenderer({
          clearColor: 0xEEEEEE,
          clearAlpha: 1,
          antialias: true
        });
        this.renderer.clear();
        this.camera = new THREE.PerspectiveCamera(this.viewAngle, ASPECT, NEAR, FAR);
        this.camera.position.z = 300;
        this.scene = new THREE.Scene();
        this.scene.add(this.camera);
        this.addObjs();
        this.setupLights();
        this.addPlane();
        this.addStuff();
        this.renderer.setSize(this.width, this.height);
        this.controller = new THREE.Object3D();
        this.controller.setCurrent = function(current) {
          return _this.current = current;
        };
        this.controller.objects = this.scene.__objects;
        this.projector = new THREE.Projector();
      }

      GlThreeView.prototype.addObjs2 = function() {
        this.cube = new THREE.Mesh(new THREE.CubeGeometry(50, 50, 50), new THREE.MeshBasicMaterial({
          color: 0x000000
        }));
        return this.scene.add(this.cube);
      };

      GlThreeView.prototype.addObjs = function() {
        var radius, rings, segments, sphere, sphereMaterial;
        sphereMaterial = new THREE.MeshLambertMaterial({
          color: 0xCC0000
        });
        radius = 50;
        segments = 16;
        rings = 16;
        sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, segments, rings), sphereMaterial);
        sphere.name = "Shinyyy";
        return this.scene.add(sphere);
      };

      GlThreeView.prototype.setupLights = function() {
        var pointLight;
        pointLight = new THREE.PointLight(0xFFFFFF);
        pointLight.position.x = 10;
        pointLight.position.y = 50;
        pointLight.position.z = 130;
        return this.scene.add(pointLight);
      };

      GlThreeView.prototype.addPlane = function() {
        var plane, planeGeo, planeMat;
        planeGeo = new THREE.PlaneGeometry(400, 400, 10, 10);
        planeMat = new THREE.LineBasicMaterial({
          color: 0xFFFFFF,
          lineWidth: 1
        });
        plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -30;
        return this.scene.add(plane);
      };

      GlThreeView.prototype.addStuff = function() {
        var line, lineGeo, lineMat, v;
        v = function(x, y, z) {
          return new THREE.Vector3(x, y, z);
        };
        lineGeo = new THREE.Geometry();
        lineGeo.vertices.push(v(-50, 0, 0), v(50, 0, 0), v(0, -50, 0), v(0, 50, 0), v(0, 0, -50), v(0, 0, 50), v(-50, 50, -50), v(50, 50, -50), v(-50, -50, -50), v(50, -50, -50), v(-50, 50, 50), v(50, 50, 50), v(-50, -50, 50), v(50, -50, 50), v(-50, 0, 50), v(50, 0, 50), v(-50, 0, -50), v(50, 0, -50), v(-50, 50, 0), v(50, 50, 0), v(-50, -50, 0), v(50, -50, 0), v(50, -50, -50), v(50, 50, -50), v(-50, -50, -50), v(-50, 50, -50), v(50, -50, 50), v(50, 50, 50), v(-50, -50, 50), v(-50, 50, 50), v(0, -50, 50), v(0, 50, 50), v(0, -50, -50), v(0, 50, -50), v(50, -50, 0), v(50, 50, 0), v(-50, -50, 0), v(-50, 50, 0), v(50, 50, -50), v(50, 50, 50), v(50, -50, -50), v(50, -50, 50), v(-50, 50, -50), v(-50, 50, 50), v(-50, -50, -50), v(-50, -50, 50), v(-50, 0, -50), v(-50, 0, 50), v(50, 0, -50), v(50, 0, 50), v(0, 50, -50), v(0, 50, 50), v(0, -50, -50), v(0, -50, 50));
        lineMat = new THREE.LineBasicMaterial({
          color: 0x808080,
          lineWidth: 1
        });
        line = new THREE.Line(lineGeo, lineMat);
        line.type = THREE.Lines;
        return this.scene.add(line);
      };

      GlThreeView.prototype.onRender = function() {
        var container;
        container = $(this.ui.renderBlock);
        container.append(this.renderer.domElement);
        return this.animate();
      };

      GlThreeView.prototype.animate = function() {
        var t;
        t = new Date().getTime();
        this.camera.position.x = Math.sin(t / 10000) * 300;
        this.camera.position.y = 150;
        this.camera.position.z = Math.cos(t / 10000) * 300;
        this.camera.lookAt(this.scene.position);
        this.renderer.render(this.scene, this.camera);
        return requestAnimationFrame(this.animate);
      };

      return GlThreeView;

    })(marionette.ItemView);
    return GlThreeView;
  });

}).call(this);
